# CostTracker Enhancement Patch

This patch adds Claude Code cost tracking and enhanced analytics to the existing modular implementation.

## File: claude_code_builder/models/cost_tracker.py

```python
"""Cost tracking for API usage and budget monitoring."""
from dataclasses import dataclass, field
from typing import Dict, Optional, List, Tuple, Any
from datetime import datetime
from collections import defaultdict
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
from rich.console import Group

from claude_code_builder.utils.constants import TOKEN_COSTS


@dataclass
class CostTracker:
    """Track API usage costs across models and phases.
    
    Provides detailed cost breakdowns by model, phase, and time period
    for accurate billing and budget monitoring.
    
    Enhanced in v2.3.0 with:
    - Separate Claude Code cost tracking
    - Research cost categorization
    - Session analytics for Claude Code executions
    """
    
    # Token usage
    total_input_tokens: int = 0
    total_output_tokens: int = 0
    
    # Total cost tracking (NEW in v2.3.0)
    total_cost: float = 0.0
    claude_code_cost: float = 0.0  # NEW: Separate Claude Code tracking
    research_cost: float = 0.0  # NEW: Separate research cost tracking
    
    # Token usage by model
    tokens_by_model: Dict[str, Dict[str, int]] = field(
        default_factory=lambda: defaultdict(lambda: {"input": 0, "output": 0})
    )
    
    # Cost tracking
    costs_by_model: Dict[str, float] = field(default_factory=lambda: defaultdict(float))
    costs_by_phase: Dict[str, float] = field(default_factory=lambda: defaultdict(float))
    costs_by_hour: Dict[str, float] = field(default_factory=lambda: defaultdict(float))
    
    # Current phase tracking
    current_phase: Optional[str] = None
    phase_start_tokens: Dict[str, int] = field(default_factory=dict)
    
    # History
    cost_history: List[Dict[str, Any]] = field(default_factory=list)
    
    # Claude Code session tracking (NEW in v2.3.0)
    claude_code_sessions: List[Dict[str, Any]] = field(default_factory=list)
    
    def add_tokens(self, model: str, input_tokens: int, output_tokens: int, phase_id: Optional[str] = None) -> float:
        """Add token usage and calculate cost.
        
        Args:
            model: The model name
            input_tokens: Number of input tokens
            output_tokens: Number of output tokens
            phase_id: Optional phase name for phase-specific tracking
            
        Returns:
            The cost for this token usage
        """
        # Update total tokens
        self.total_input_tokens += input_tokens
        self.total_output_tokens += output_tokens
        
        # Update model-specific tokens
        self.tokens_by_model[model]["input"] += input_tokens
        self.tokens_by_model[model]["output"] += output_tokens
        
        # Calculate cost
        cost = self._calculate_cost(model, input_tokens, output_tokens)
        
        # Update cost tracking
        self.costs_by_model[model] += cost
        self.total_cost += cost  # NEW: Update total cost
        
        # Track by phase if provided
        phase_id = phase_id or self.current_phase
        if phase_id:
            self.costs_by_phase[phase_id] += cost
            
            # Track research costs separately (NEW in v2.3.0)
            if "research" in phase_id.lower():
                self.research_cost += cost
        
        # Track by hour
        hour_key = datetime.now().strftime("%Y-%m-%d %H:00")
        self.costs_by_hour[hour_key] += cost
        
        # Add to history
        self.cost_history.append({
            "timestamp": datetime.now().isoformat(),
            "model": model,
            "input_tokens": input_tokens,
            "output_tokens": output_tokens,
            "cost": cost,
            "phase": phase_id
        })
        
        return cost
    
    def add_claude_code_cost(self, cost: float, session_data: Dict[str, Any]) -> None:
        """Add Claude Code execution cost with session tracking.
        
        NEW in v2.3.0: Track Claude Code costs separately with detailed analytics.
        
        Args:
            cost: The cost of the Claude Code session
            session_data: Metadata about the session including:
                - session_id: Unique session identifier
                - duration_ms: Session duration in milliseconds
                - num_turns: Number of conversation turns
                - phase: Phase name for tracking
        """
        self.claude_code_cost += cost
        self.total_cost += cost
        
        # Store session data for analysis
        session_info = {
            "cost": cost,
            "timestamp": datetime.now().isoformat(),
            "session_id": session_data.get("session_id"),
            "duration_ms": session_data.get("duration_ms"),
            "num_turns": session_data.get("num_turns"),
            "phase": session_data.get("phase", "unknown")
        }
        self.claude_code_sessions.append(session_info)
        
        # Add to phase costs
        phase = session_data.get("phase", "claude_code_execution")
        if phase not in self.costs_by_phase:
            self.costs_by_phase[phase] = 0.0
        self.costs_by_phase[phase] += cost
    
    def set_current_phase(self, phase: str) -> None:
        """Set the current phase for tracking."""
        self.current_phase = phase
        self.phase_start_tokens[phase] = self.total_input_tokens + self.total_output_tokens
    
    def _calculate_cost(self, model: str, input_tokens: int, output_tokens: int) -> float:
        """Calculate cost for given token usage.
        
        Args:
            model: The model name
            input_tokens: Number of input tokens
            output_tokens: Number of output tokens
            
        Returns:
            Cost in USD
        """
        if model not in TOKEN_COSTS:
            # Default to most expensive model for safety
            model = 'claude-opus-4-20250514'
        
        costs = TOKEN_COSTS[model]
        
        # Convert to cost per token (costs are per 1M tokens)
        input_cost = (input_tokens / 1_000_000) * costs['input']
        output_cost = (output_tokens / 1_000_000) * costs['output']
        
        return input_cost + output_cost
    
    @property
    def analysis_cost(self) -> float:
        """Calculate cost for non-Claude-Code, non-research API calls.
        
        NEW in v2.3.0: Separate analysis cost category.
        """
        return self.total_cost - self.claude_code_cost - self.research_cost
    
    @property
    def average_cost_per_phase(self) -> float:
        """Calculate average cost per phase."""
        if not self.costs_by_phase:
            return 0.0
        return self.total_cost / len(self.costs_by_phase)
    
    @property
    def most_expensive_model(self) -> Optional[Tuple[str, float]]:
        """Get the most expensive model by total cost."""
        if not self.costs_by_model:
            return None
        model = max(self.costs_by_model.items(), key=lambda x: x[1])
        return model
    
    @property
    def most_expensive_phase(self) -> Optional[Tuple[str, float]]:
        """Get the most expensive phase by total cost."""
        if not self.costs_by_phase:
            return None
        phase = max(self.costs_by_phase.items(), key=lambda x: x[1])
        return phase
    
    def get_model_summary(self) -> Dict[str, Dict[str, Any]]:
        """Get detailed summary by model."""
        summary = {}
        for model, tokens in self.tokens_by_model.items():
            summary[model] = {
                "input_tokens": tokens["input"],
                "output_tokens": tokens["output"],
                "total_tokens": tokens["input"] + tokens["output"],
                "cost": self.costs_by_model[model],
                "percentage": (self.costs_by_model[model] / self.total_cost * 100) if self.total_cost > 0 else 0
            }
        return summary
    
    def get_phase_summary(self) -> Dict[str, Dict[str, Any]]:
        """Get detailed summary by phase."""
        summary = {}
        for phase, cost in self.costs_by_phase.items():
            summary[phase] = {
                "cost": cost,
                "percentage": (cost / self.total_cost * 100) if self.total_cost > 0 else 0
            }
        return summary
    
    def get_phase_cost(self, phase_id: str) -> float:
        """Get the total cost for a specific phase.
        
        Args:
            phase_id: The phase ID to get cost for
            
        Returns:
            Total cost for the phase
        """
        return self.costs_by_phase.get(phase_id, 0.0)
    
    def get_model_breakdown(self) -> List[Dict[str, Any]]:
        """Get cost breakdown by model including Claude Code.
        
        NEW in v2.3.0: Comprehensive model breakdown with Claude Code.
        
        Returns:
            List of model cost breakdowns sorted by cost
        """
        breakdown = []
        
        # Add traditional model costs
        for model, usage in self.tokens_by_model.items():
            if model in TOKEN_COSTS:
                input_cost = (usage["input"] / 1_000_000) * TOKEN_COSTS[model]["input"]
                output_cost = (usage["output"] / 1_000_000) * TOKEN_COSTS[model]["output"]
                total_cost = input_cost + output_cost
                
                breakdown.append({
                    "model": model,
                    "input_tokens": usage["input"],
                    "output_tokens": usage["output"],
                    "total_tokens": usage["input"] + usage["output"],
                    "cost": round(total_cost, 2)
                })
        
        # Add Claude Code as a separate entry
        if self.claude_code_cost > 0:
            avg_turns = 0
            if self.claude_code_sessions:
                total_turns = sum(s.get("num_turns", 0) for s in self.claude_code_sessions)
                avg_turns = total_turns / len(self.claude_code_sessions)
            
            breakdown.append({
                "model": "claude-code-execution",
                "sessions": len(self.claude_code_sessions),
                "avg_turns": round(avg_turns, 1),
                "cost": round(self.claude_code_cost, 2)
            })
        
        return sorted(breakdown, key=lambda x: x["cost"], reverse=True)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization.
        
        Enhanced in v2.3.0 with new fields.
        """
        # Calculate average Claude Code cost
        avg_claude_code_cost = 0.0
        if self.claude_code_sessions:
            avg_claude_code_cost = self.claude_code_cost / len(self.claude_code_sessions)
        
        return {
            "total_cost": self.total_cost,
            "total_input_tokens": self.total_input_tokens,
            "total_output_tokens": self.total_output_tokens,
            "total_tokens": self.total_input_tokens + self.total_output_tokens,
            "claude_code_cost": round(self.claude_code_cost, 2),  # NEW
            "research_cost": round(self.research_cost, 2),  # NEW
            "analysis_cost": round(self.analysis_cost, 2),  # NEW
            "costs_by_model": dict(self.costs_by_model),
            "costs_by_phase": dict(self.costs_by_phase),
            "costs_by_hour": dict(self.costs_by_hour),
            "tokens_by_model": dict(self.tokens_by_model),
            "average_cost_per_phase": self.average_cost_per_phase,
            "most_expensive_model": self.most_expensive_model,
            "most_expensive_phase": self.most_expensive_phase,
            "model_summary": self.get_model_summary(),
            "phase_summary": self.get_phase_summary(),
            "model_breakdown": self.get_model_breakdown(),  # NEW
            "claude_code_sessions": len(self.claude_code_sessions),  # NEW
            "avg_claude_code_cost": round(avg_claude_code_cost, 4)  # NEW
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CostTracker':
        """Create CostTracker from dictionary.
        
        Enhanced in v2.3.0 to handle new fields gracefully.
        
        Args:
            data: Dictionary containing cost tracker data
            
        Returns:
            CostTracker instance
        """
        tracker = cls()
        
        # Restore token counts
        tracker.total_input_tokens = data.get("total_input_tokens", 0)
        tracker.total_output_tokens = data.get("total_output_tokens", 0)
        
        # Restore costs (with v2.3.0 fields)
        tracker.total_cost = data.get("total_cost", 0.0)
        tracker.claude_code_cost = data.get("claude_code_cost", 0.0)
        tracker.research_cost = data.get("research_cost", 0.0)
        
        # Restore dictionaries
        tracker.costs_by_model = defaultdict(float, data.get("costs_by_model", {}))
        tracker.costs_by_phase = defaultdict(float, data.get("costs_by_phase", {}))
        tracker.costs_by_hour = defaultdict(float, data.get("costs_by_hour", {}))
        
        # Restore token usage by model
        tokens_data = data.get("tokens_by_model", {})
        for model, tokens in tokens_data.items():
            tracker.tokens_by_model[model] = defaultdict(int, tokens)
        
        # Restore Claude Code sessions if present
        if "claude_code_sessions" in data and isinstance(data["claude_code_sessions"], list):
            tracker.claude_code_sessions = data["claude_code_sessions"]
        
        # Calculate total_cost if not present (backward compatibility)
        if tracker.total_cost == 0.0 and tracker.costs_by_model:
            tracker.total_cost = sum(tracker.costs_by_model.values())
        
        return tracker
    
    def __rich__(self) -> Panel:
        """Rich representation for terminal display.
        
        Enhanced in v2.3.0 with Claude Code cost display.
        """
        # Create cost summary table
        summary_table = Table(title="Cost Summary", show_header=True, header_style="bold cyan")
        summary_table.add_column("Metric", style="yellow")
        summary_table.add_column("Value", style="white")
        
        summary_table.add_row("Total Cost", f"${self.total_cost:.4f}")
        summary_table.add_row("‚îú‚îÄ Claude Code", f"${self.claude_code_cost:.4f}")  # NEW
        summary_table.add_row("‚îú‚îÄ Research", f"${self.research_cost:.4f}")  # NEW
        summary_table.add_row("‚îî‚îÄ Analysis", f"${self.analysis_cost:.4f}")  # NEW
        summary_table.add_row("Input Tokens", f"{self.total_input_tokens:,}")
        summary_table.add_row("Output Tokens", f"{self.total_output_tokens:,}")
        summary_table.add_row("Total Tokens", f"{self.total_input_tokens + self.total_output_tokens:,}")
        
        if self.costs_by_phase:
            summary_table.add_row("Average Cost/Phase", f"${self.average_cost_per_phase:.4f}")
        
        if self.claude_code_sessions:  # NEW
            avg_cost = self.claude_code_cost / len(self.claude_code_sessions)
            summary_table.add_row("Claude Code Sessions", str(len(self.claude_code_sessions)))
            summary_table.add_row("Avg Cost/Session", f"${avg_cost:.4f}")
        
        # Create model breakdown table
        if self.costs_by_model or self.claude_code_cost > 0:
            model_table = Table(title="Cost by Model", show_header=True)
            model_table.add_column("Model", style="cyan")
            model_table.add_column("Cost", style="white")
            model_table.add_column("Tokens", style="dim")
            model_table.add_column("%", style="yellow")
            
            # Traditional models
            for model, summary in self.get_model_summary().items():
                model_table.add_row(
                    model,
                    f"${summary['cost']:.4f}",
                    f"{summary['total_tokens']:,}",
                    f"{summary['percentage']:.1f}%"
                )
            
            # Claude Code execution (NEW)
            if self.claude_code_cost > 0:
                percentage = (self.claude_code_cost / self.total_cost * 100) if self.total_cost > 0 else 0
                model_table.add_row(
                    "claude-code-execution",
                    f"${self.claude_code_cost:.4f}",
                    f"{len(self.claude_code_sessions)} sessions",
                    f"{percentage:.1f}%"
                )
        
        # Create phase breakdown table
        if self.costs_by_phase:
            phase_table = Table(title="Cost by Phase", show_header=True)
            phase_table.add_column("Phase", style="magenta")
            phase_table.add_column("Cost", style="white")
            phase_table.add_column("%", style="yellow")
            
            for phase, summary in self.get_phase_summary().items():
                phase_table.add_row(
                    phase,
                    f"${summary['cost']:.4f}",
                    f"{summary['percentage']:.1f}%"
                )
        
        # Combine tables
        content = [summary_table]
        if self.costs_by_model or self.claude_code_cost > 0:
            content.append(model_table)
        if self.costs_by_phase:
            content.append(phase_table)
        
        # Add warning if costs are high
        if self.total_cost > 10.0:
            warning = Text()
            warning.append("‚ö†Ô∏è  ", style="yellow")
            warning.append("High API costs detected! ", style="bold yellow")
            warning.append(f"Current total: ${self.total_cost:.2f}", style="red")
            content.append(warning)
        
        return Panel(
            Group(*content),
            title="üí∞ Cost Tracking",
            border_style="green" if self.total_cost < 10 else "yellow",
            expand=False
        )
```

## Integration Points

### 1. Update ClaudeCodeExecutor
In `claude_code_builder/execution/executor.py`, after parsing cost from stream:

```python
# After extracting cost from Claude Code output
if cost_info and self.cost_tracker:
    session_data = {
        "session_id": session_id,
        "duration_ms": duration_ms,
        "num_turns": num_turns,
        "phase": self.current_phase
    }
    self.cost_tracker.add_claude_code_cost(cost_info['total_cost'], session_data)
```

### 2. Update ResearchManager
In `claude_code_builder/research/manager.py`, when adding research costs:

```python
# When adding research costs
if agent_result and 'usage' in agent_result:
    self.cost_tracker.add_tokens(
        model=self.model,
        input_tokens=usage.input_tokens,
        output_tokens=usage.output_tokens,
        phase_id=f"research_{agent_name}"  # Ensures research tracking
    )
```

### 3. Update UI Displays
In `claude_code_builder/ui/display.py`, show cost breakdown:

```python
# In the cost display section
cost_summary = self.cost_tracker.to_dict()
console.print(f"Total Cost: ${cost_summary['total_cost']:.2f}")
console.print(f"‚îú‚îÄ Claude Code: ${cost_summary['claude_code_cost']:.2f} ({cost_summary['claude_code_sessions']} sessions)")
console.print(f"‚îú‚îÄ Research: ${cost_summary['research_cost']:.2f}")
console.print(f"‚îî‚îÄ Analysis: ${cost_summary['analysis_cost']:.2f}")
```